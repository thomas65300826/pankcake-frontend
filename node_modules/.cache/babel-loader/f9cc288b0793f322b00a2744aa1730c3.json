{"ast":null,"code":"import BigNumber from 'bignumber.js';\nimport poolsConfig from 'config/constants/pools';\nimport sousChefABI from 'config/abi/sousChef.json';\nimport cakeABI from 'config/abi/cake.json';\nimport wbnbABI from 'config/abi/weth.json';\nimport multicall from 'utils/multicall';\nimport { getAddress, getWbnbAddress } from 'utils/addressHelpers';\nimport { BIG_ZERO } from 'utils/bigNumber';\nimport { getSouschefV2Contract } from 'utils/contractHelpers';\nexport const fetchPoolsBlockLimits = async () => {\n  const poolsWithEnd = poolsConfig.filter(p => p.sousId !== 0);\n  const callsStartBlock = poolsWithEnd.map(poolConfig => {\n    return {\n      address: getAddress(poolConfig.contractAddress),\n      name: 'startBlock'\n    };\n  });\n  const callsEndBlock = poolsWithEnd.map(poolConfig => {\n    return {\n      address: getAddress(poolConfig.contractAddress),\n      name: 'bonusEndBlock'\n    };\n  });\n  const starts = await multicall(sousChefABI, callsStartBlock);\n  const ends = await multicall(sousChefABI, callsEndBlock);\n  return poolsWithEnd.map((cakePoolConfig, index) => {\n    const startBlock = starts[index];\n    const endBlock = ends[index];\n    return {\n      sousId: cakePoolConfig.sousId,\n      startBlock: new BigNumber(startBlock).toJSON(),\n      endBlock: new BigNumber(endBlock).toJSON()\n    };\n  });\n};\nexport const fetchPoolsTotalStaking = async () => {\n  const nonBnbPools = poolsConfig.filter(p => p.stakingToken.symbol !== 'BNB');\n  const bnbPool = poolsConfig.filter(p => p.stakingToken.symbol === 'BNB');\n  const callsNonBnbPools = nonBnbPools.map(poolConfig => {\n    return {\n      address: getAddress(poolConfig.stakingToken.address),\n      name: 'balanceOf',\n      params: [getAddress(poolConfig.contractAddress)]\n    };\n  });\n  const callsBnbPools = bnbPool.map(poolConfig => {\n    return {\n      address: getWbnbAddress(),\n      name: 'balanceOf',\n      params: [getAddress(poolConfig.contractAddress)]\n    };\n  });\n  const nonBnbPoolsTotalStaked = await multicall(cakeABI, callsNonBnbPools);\n  const bnbPoolsTotalStaked = await multicall(wbnbABI, callsBnbPools);\n  return [...nonBnbPools.map((p, index) => ({\n    sousId: p.sousId,\n    totalStaked: new BigNumber(nonBnbPoolsTotalStaked[index]).toJSON()\n  })), ...bnbPool.map((p, index) => ({\n    sousId: p.sousId,\n    totalStaked: new BigNumber(bnbPoolsTotalStaked[index]).toJSON()\n  }))];\n};\nexport const fetchPoolStakingLimit = async sousId => {\n  try {\n    const sousContract = getSouschefV2Contract(sousId);\n    const stakingLimit = await sousContract.poolLimitPerUser();\n    return new BigNumber(stakingLimit.toString());\n  } catch (error) {\n    return BIG_ZERO;\n  }\n};\nexport const fetchPoolsStakingLimits = async poolsWithStakingLimit => {\n  const validPools = poolsConfig.filter(p => p.stakingToken.symbol !== 'BNB' && !p.isFinished).filter(p => !poolsWithStakingLimit.includes(p.sousId)); // Get the staking limit for each valid pool\n  // Note: We cannot batch the calls via multicall because V1 pools do not have \"poolLimitPerUser\" and will throw an error\n\n  const stakingLimitPromises = validPools.map(validPool => fetchPoolStakingLimit(validPool.sousId));\n  const stakingLimits = await Promise.all(stakingLimitPromises);\n  return stakingLimits.reduce((accum, stakingLimit, index) => {\n    return { ...accum,\n      [validPools[index].sousId]: stakingLimit\n    };\n  }, {});\n};","map":{"version":3,"sources":["/Users/thomas/Documents/pancake-frontend/src/state/pools/fetchPools.ts"],"names":["BigNumber","poolsConfig","sousChefABI","cakeABI","wbnbABI","multicall","getAddress","getWbnbAddress","BIG_ZERO","getSouschefV2Contract","fetchPoolsBlockLimits","poolsWithEnd","filter","p","sousId","callsStartBlock","map","poolConfig","address","contractAddress","name","callsEndBlock","starts","ends","cakePoolConfig","index","startBlock","endBlock","toJSON","fetchPoolsTotalStaking","nonBnbPools","stakingToken","symbol","bnbPool","callsNonBnbPools","params","callsBnbPools","nonBnbPoolsTotalStaked","bnbPoolsTotalStaked","totalStaked","fetchPoolStakingLimit","sousContract","stakingLimit","poolLimitPerUser","toString","error","fetchPoolsStakingLimits","poolsWithStakingLimit","validPools","isFinished","includes","stakingLimitPromises","validPool","stakingLimits","Promise","all","reduce","accum"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js'\nimport poolsConfig from 'config/constants/pools'\nimport sousChefABI from 'config/abi/sousChef.json'\nimport cakeABI from 'config/abi/cake.json'\nimport wbnbABI from 'config/abi/weth.json'\nimport multicall from 'utils/multicall'\nimport { getAddress, getWbnbAddress } from 'utils/addressHelpers'\nimport { BIG_ZERO } from 'utils/bigNumber'\nimport { getSouschefV2Contract } from 'utils/contractHelpers'\n\nexport const fetchPoolsBlockLimits = async () => {\n  const poolsWithEnd = poolsConfig.filter((p) => p.sousId !== 0)\n  const callsStartBlock = poolsWithEnd.map((poolConfig) => {\n    return {\n      address: getAddress(poolConfig.contractAddress),\n      name: 'startBlock',\n    }\n  })\n  const callsEndBlock = poolsWithEnd.map((poolConfig) => {\n    return {\n      address: getAddress(poolConfig.contractAddress),\n      name: 'bonusEndBlock',\n    }\n  })\n\n  const starts = await multicall(sousChefABI, callsStartBlock)\n  const ends = await multicall(sousChefABI, callsEndBlock)\n\n  return poolsWithEnd.map((cakePoolConfig, index) => {\n    const startBlock = starts[index]\n    const endBlock = ends[index]\n    return {\n      sousId: cakePoolConfig.sousId,\n      startBlock: new BigNumber(startBlock).toJSON(),\n      endBlock: new BigNumber(endBlock).toJSON(),\n    }\n  })\n}\n\nexport const fetchPoolsTotalStaking = async () => {\n  const nonBnbPools = poolsConfig.filter((p) => p.stakingToken.symbol !== 'BNB')\n  const bnbPool = poolsConfig.filter((p) => p.stakingToken.symbol === 'BNB')\n\n  const callsNonBnbPools = nonBnbPools.map((poolConfig) => {\n    return {\n      address: getAddress(poolConfig.stakingToken.address),\n      name: 'balanceOf',\n      params: [getAddress(poolConfig.contractAddress)],\n    }\n  })\n\n  const callsBnbPools = bnbPool.map((poolConfig) => {\n    return {\n      address: getWbnbAddress(),\n      name: 'balanceOf',\n      params: [getAddress(poolConfig.contractAddress)],\n    }\n  })\n\n  const nonBnbPoolsTotalStaked = await multicall(cakeABI, callsNonBnbPools)\n  const bnbPoolsTotalStaked = await multicall(wbnbABI, callsBnbPools)\n\n  return [\n    ...nonBnbPools.map((p, index) => ({\n      sousId: p.sousId,\n      totalStaked: new BigNumber(nonBnbPoolsTotalStaked[index]).toJSON(),\n    })),\n    ...bnbPool.map((p, index) => ({\n      sousId: p.sousId,\n      totalStaked: new BigNumber(bnbPoolsTotalStaked[index]).toJSON(),\n    })),\n  ]\n}\n\nexport const fetchPoolStakingLimit = async (sousId: number): Promise<BigNumber> => {\n  try {\n    const sousContract = getSouschefV2Contract(sousId)\n    const stakingLimit = await sousContract.poolLimitPerUser()\n    return new BigNumber(stakingLimit.toString())\n  } catch (error) {\n    return BIG_ZERO\n  }\n}\n\nexport const fetchPoolsStakingLimits = async (\n  poolsWithStakingLimit: number[],\n): Promise<{ [key: string]: BigNumber }> => {\n  const validPools = poolsConfig\n    .filter((p) => p.stakingToken.symbol !== 'BNB' && !p.isFinished)\n    .filter((p) => !poolsWithStakingLimit.includes(p.sousId))\n\n  // Get the staking limit for each valid pool\n  // Note: We cannot batch the calls via multicall because V1 pools do not have \"poolLimitPerUser\" and will throw an error\n  const stakingLimitPromises = validPools.map((validPool) => fetchPoolStakingLimit(validPool.sousId))\n  const stakingLimits = await Promise.all(stakingLimitPromises)\n\n  return stakingLimits.reduce((accum, stakingLimit, index) => {\n    return {\n      ...accum,\n      [validPools[index].sousId]: stakingLimit,\n    }\n  }, {})\n}\n"]},"metadata":{},"sourceType":"module"}