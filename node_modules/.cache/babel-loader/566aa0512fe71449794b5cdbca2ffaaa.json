{"ast":null,"code":"import Nfts, { IPFS_GATEWAY, nftSources } from 'config/constants/nfts';\nimport { getAddress } from './addressHelpers';\nimport { getErc721Contract } from './contractHelpers';\n/**\n * Gets the identifier key based on the nft address\n * Helpful for looking up the key when all you have is the address\n */\n\nexport const getIdentifierKeyFromAddress = nftAddress => {\n  const nftSource = Object.values(nftSources).find(nftSourceEntry => {\n    const address = getAddress(nftSourceEntry.address);\n    return address === nftAddress;\n  });\n  return nftSource ? nftSource.identifierKey : null;\n};\n/**\n * Some sources like Pancake do not return HTTP tokenURI's\n */\n\nexport const getTokenUrl = tokenUri => {\n  if (tokenUri.startsWith('ipfs://')) {\n    return `${IPFS_GATEWAY}/ipfs/${tokenUri.slice(6)}`;\n  }\n\n  return tokenUri;\n};\nexport const getAddressByType = type => {\n  return getAddress(nftSources[type].address);\n};\nexport const getTokenUriData = async (nftAddress, tokenId) => {\n  try {\n    const contract = getErc721Contract(nftAddress);\n    const tokenUri = await contract.tokenURI(tokenId);\n    const uriDataResponse = await fetch(getTokenUrl(tokenUri));\n\n    if (!uriDataResponse.ok) {\n      return null;\n    }\n\n    const uriData = await uriDataResponse.json();\n    return uriData;\n  } catch (error) {\n    console.error('getTokenUriData', error);\n    return null;\n  }\n};\nexport const getNftByTokenId = async (nftAddress, tokenId) => {\n  const uriData = await getTokenUriData(nftAddress, tokenId);\n  const identifierKey = getIdentifierKeyFromAddress(nftAddress); // Bail out early if we have no uriData, identifierKey, or the value does not\n  // exist in the object\n\n  if (!uriData) {\n    return null;\n  }\n\n  if (!identifierKey) {\n    return null;\n  }\n\n  if (!uriData[identifierKey]) {\n    return null;\n  }\n\n  return Nfts.find(nft => {\n    return uriData[identifierKey].includes(nft.identifier);\n  });\n};","map":{"version":3,"sources":["/Users/thomas/Documents/PycharmProjects/pancake-frontend/src/utils/collectibles.ts"],"names":["Nfts","IPFS_GATEWAY","nftSources","getAddress","getErc721Contract","getIdentifierKeyFromAddress","nftAddress","nftSource","Object","values","find","nftSourceEntry","address","identifierKey","getTokenUrl","tokenUri","startsWith","slice","getAddressByType","type","getTokenUriData","tokenId","contract","tokenURI","uriDataResponse","fetch","ok","uriData","json","error","console","getNftByTokenId","nft","includes","identifier"],"mappings":"AAAA,OAAOA,IAAP,IAAeC,YAAf,EAA6BC,UAA7B,QAA+C,uBAA/C;AAEA,SAASC,UAAT,QAA2B,kBAA3B;AACA,SAASC,iBAAT,QAAkC,mBAAlC;AAEA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,2BAA2B,GAAIC,UAAD,IAAwB;AACjE,QAAMC,SAAS,GAAGC,MAAM,CAACC,MAAP,CAAcP,UAAd,EAA0BQ,IAA1B,CAAgCC,cAAD,IAAoB;AACnE,UAAMC,OAAO,GAAGT,UAAU,CAACQ,cAAc,CAACC,OAAhB,CAA1B;AACA,WAAOA,OAAO,KAAKN,UAAnB;AACD,GAHiB,CAAlB;AAKA,SAAOC,SAAS,GAAGA,SAAS,CAACM,aAAb,GAA6B,IAA7C;AACD,CAPM;AASP;AACA;AACA;;AACA,OAAO,MAAMC,WAAW,GAAIC,QAAD,IAAsB;AAC/C,MAAIA,QAAQ,CAACC,UAAT,CAAoB,SAApB,CAAJ,EAAoC;AAClC,WAAQ,GAAEf,YAAa,SAAQc,QAAQ,CAACE,KAAT,CAAe,CAAf,CAAkB,EAAjD;AACD;;AAED,SAAOF,QAAP;AACD,CANM;AAQP,OAAO,MAAMG,gBAAgB,GAAIC,IAAD,IAAmB;AACjD,SAAOhB,UAAU,CAACD,UAAU,CAACiB,IAAD,CAAV,CAAiBP,OAAlB,CAAjB;AACD,CAFM;AAIP,OAAO,MAAMQ,eAAe,GAAG,OAAOd,UAAP,EAA2Be,OAA3B,KAA+C;AAC5E,MAAI;AACF,UAAMC,QAAQ,GAAGlB,iBAAiB,CAACE,UAAD,CAAlC;AACA,UAAMS,QAAQ,GAAG,MAAMO,QAAQ,CAACC,QAAT,CAAkBF,OAAlB,CAAvB;AACA,UAAMG,eAAe,GAAG,MAAMC,KAAK,CAACX,WAAW,CAACC,QAAD,CAAZ,CAAnC;;AAEA,QAAI,CAACS,eAAe,CAACE,EAArB,EAAyB;AACvB,aAAO,IAAP;AACD;;AAED,UAAMC,OAAO,GAAG,MAAMH,eAAe,CAACI,IAAhB,EAAtB;AACA,WAAOD,OAAP;AACD,GAXD,CAWE,OAAOE,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACD,KAAR,CAAc,iBAAd,EAAiCA,KAAjC;AACA,WAAO,IAAP;AACD;AACF,CAhBM;AAkBP,OAAO,MAAME,eAAe,GAAG,OAAOzB,UAAP,EAA2Be,OAA3B,KAAoE;AACjG,QAAMM,OAAO,GAAG,MAAMP,eAAe,CAACd,UAAD,EAAae,OAAb,CAArC;AACA,QAAMR,aAAa,GAAGR,2BAA2B,CAACC,UAAD,CAAjD,CAFiG,CAIjG;AACA;;AACA,MAAI,CAACqB,OAAL,EAAc;AACZ,WAAO,IAAP;AACD;;AAED,MAAI,CAACd,aAAL,EAAoB;AAClB,WAAO,IAAP;AACD;;AAED,MAAI,CAACc,OAAO,CAACd,aAAD,CAAZ,EAA6B;AAC3B,WAAO,IAAP;AACD;;AAED,SAAOb,IAAI,CAACU,IAAL,CAAWsB,GAAD,IAAS;AACxB,WAAOL,OAAO,CAACd,aAAD,CAAP,CAAuBoB,QAAvB,CAAgCD,GAAG,CAACE,UAApC,CAAP;AACD,GAFM,CAAP;AAGD,CArBM","sourcesContent":["import Nfts, { IPFS_GATEWAY, nftSources } from 'config/constants/nfts'\nimport { Nft, NftType } from 'config/constants/types'\nimport { getAddress } from './addressHelpers'\nimport { getErc721Contract } from './contractHelpers'\n\n/**\n * Gets the identifier key based on the nft address\n * Helpful for looking up the key when all you have is the address\n */\nexport const getIdentifierKeyFromAddress = (nftAddress: string) => {\n  const nftSource = Object.values(nftSources).find((nftSourceEntry) => {\n    const address = getAddress(nftSourceEntry.address)\n    return address === nftAddress\n  })\n\n  return nftSource ? nftSource.identifierKey : null\n}\n\n/**\n * Some sources like Pancake do not return HTTP tokenURI's\n */\nexport const getTokenUrl = (tokenUri: string) => {\n  if (tokenUri.startsWith('ipfs://')) {\n    return `${IPFS_GATEWAY}/ipfs/${tokenUri.slice(6)}`\n  }\n\n  return tokenUri\n}\n\nexport const getAddressByType = (type: NftType) => {\n  return getAddress(nftSources[type].address)\n}\n\nexport const getTokenUriData = async (nftAddress: string, tokenId: number) => {\n  try {\n    const contract = getErc721Contract(nftAddress)\n    const tokenUri = await contract.tokenURI(tokenId)\n    const uriDataResponse = await fetch(getTokenUrl(tokenUri))\n\n    if (!uriDataResponse.ok) {\n      return null\n    }\n\n    const uriData = await uriDataResponse.json()\n    return uriData\n  } catch (error) {\n    console.error('getTokenUriData', error)\n    return null\n  }\n}\n\nexport const getNftByTokenId = async (nftAddress: string, tokenId: number): Promise<Nft | null> => {\n  const uriData = await getTokenUriData(nftAddress, tokenId)\n  const identifierKey = getIdentifierKeyFromAddress(nftAddress)\n\n  // Bail out early if we have no uriData, identifierKey, or the value does not\n  // exist in the object\n  if (!uriData) {\n    return null\n  }\n\n  if (!identifierKey) {\n    return null\n  }\n\n  if (!uriData[identifierKey]) {\n    return null\n  }\n\n  return Nfts.find((nft) => {\n    return uriData[identifierKey].includes(nft.identifier)\n  })\n}\n"]},"metadata":{},"sourceType":"module"}