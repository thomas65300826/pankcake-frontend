{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState, useRef } from 'react';\nimport { useAppDispatch } from 'state';\nimport { useLottery } from 'state/lottery/hooks';\nimport { fetchCurrentLottery, setLotteryIsTransitioning } from 'state/lottery';\n\nconst useNextEventCountdown = nextEventTime => {\n  _s();\n\n  const dispatch = useAppDispatch();\n  const [secondsRemaining, setSecondsRemaining] = useState(null);\n  const timer = useRef(null);\n  const {\n    currentLotteryId\n  } = useLottery();\n  useEffect(() => {\n    dispatch(setLotteryIsTransitioning({\n      isTransitioning: false\n    }));\n    const currentSeconds = Math.floor(Date.now() / 1000);\n    const secondsRemainingCalc = nextEventTime - currentSeconds;\n    setSecondsRemaining(secondsRemainingCalc);\n    timer.current = setInterval(() => {\n      setSecondsRemaining(prevSecondsRemaining => {\n        // Clear current interval at end of countdown and fetch current lottery to get updated state\n        if (prevSecondsRemaining <= 1) {\n          clearInterval(timer.current);\n          dispatch(setLotteryIsTransitioning({\n            isTransitioning: true\n          }));\n          dispatch(fetchCurrentLottery({\n            currentLotteryId\n          }));\n        }\n\n        return prevSecondsRemaining - 1;\n      });\n    }, 1000);\n    return () => clearInterval(timer.current);\n  }, [setSecondsRemaining, nextEventTime, currentLotteryId, timer, dispatch]);\n  return secondsRemaining;\n};\n\n_s(useNextEventCountdown, \"gmkNpyD55+zyj0vzxlz9Jpyq71g=\", false, function () {\n  return [useAppDispatch, useLottery];\n});\n\nexport default useNextEventCountdown;","map":{"version":3,"sources":["/Users/thomas/Documents/PycharmProjects/pancake-frontend/src/views/Lottery/hooks/useNextEventCountdown.ts"],"names":["useEffect","useState","useRef","useAppDispatch","useLottery","fetchCurrentLottery","setLotteryIsTransitioning","useNextEventCountdown","nextEventTime","dispatch","secondsRemaining","setSecondsRemaining","timer","currentLotteryId","isTransitioning","currentSeconds","Math","floor","Date","now","secondsRemainingCalc","current","setInterval","prevSecondsRemaining","clearInterval"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,QAApB,EAA8BC,MAA9B,QAA4C,OAA5C;AACA,SAASC,cAAT,QAA+B,OAA/B;AACA,SAASC,UAAT,QAA2B,qBAA3B;AACA,SAASC,mBAAT,EAA8BC,yBAA9B,QAA+D,eAA/D;;AAEA,MAAMC,qBAAqB,GAAIC,aAAD,IAAmC;AAAA;;AAC/D,QAAMC,QAAQ,GAAGN,cAAc,EAA/B;AACA,QAAM,CAACO,gBAAD,EAAmBC,mBAAnB,IAA0CV,QAAQ,CAAC,IAAD,CAAxD;AACA,QAAMW,KAAK,GAAGV,MAAM,CAAC,IAAD,CAApB;AACA,QAAM;AAAEW,IAAAA;AAAF,MAAuBT,UAAU,EAAvC;AAEAJ,EAAAA,SAAS,CAAC,MAAM;AACdS,IAAAA,QAAQ,CAACH,yBAAyB,CAAC;AAAEQ,MAAAA,eAAe,EAAE;AAAnB,KAAD,CAA1B,CAAR;AACA,UAAMC,cAAc,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAvB;AACA,UAAMC,oBAAoB,GAAGZ,aAAa,GAAGO,cAA7C;AACAJ,IAAAA,mBAAmB,CAACS,oBAAD,CAAnB;AAEAR,IAAAA,KAAK,CAACS,OAAN,GAAgBC,WAAW,CAAC,MAAM;AAChCX,MAAAA,mBAAmB,CAAEY,oBAAD,IAA0B;AAC5C;AACA,YAAIA,oBAAoB,IAAI,CAA5B,EAA+B;AAC7BC,UAAAA,aAAa,CAACZ,KAAK,CAACS,OAAP,CAAb;AACAZ,UAAAA,QAAQ,CAACH,yBAAyB,CAAC;AAAEQ,YAAAA,eAAe,EAAE;AAAnB,WAAD,CAA1B,CAAR;AACAL,UAAAA,QAAQ,CAACJ,mBAAmB,CAAC;AAAEQ,YAAAA;AAAF,WAAD,CAApB,CAAR;AACD;;AACD,eAAOU,oBAAoB,GAAG,CAA9B;AACD,OARkB,CAAnB;AASD,KAV0B,EAUxB,IAVwB,CAA3B;AAYA,WAAO,MAAMC,aAAa,CAACZ,KAAK,CAACS,OAAP,CAA1B;AACD,GAnBQ,EAmBN,CAACV,mBAAD,EAAsBH,aAAtB,EAAqCK,gBAArC,EAAuDD,KAAvD,EAA8DH,QAA9D,CAnBM,CAAT;AAqBA,SAAOC,gBAAP;AACD,CA5BD;;GAAMH,qB;UACaJ,c,EAGYC,U;;;AA0B/B,eAAeG,qBAAf","sourcesContent":["import { useEffect, useState, useRef } from 'react'\nimport { useAppDispatch } from 'state'\nimport { useLottery } from 'state/lottery/hooks'\nimport { fetchCurrentLottery, setLotteryIsTransitioning } from 'state/lottery'\n\nconst useNextEventCountdown = (nextEventTime: number): number => {\n  const dispatch = useAppDispatch()\n  const [secondsRemaining, setSecondsRemaining] = useState(null)\n  const timer = useRef(null)\n  const { currentLotteryId } = useLottery()\n\n  useEffect(() => {\n    dispatch(setLotteryIsTransitioning({ isTransitioning: false }))\n    const currentSeconds = Math.floor(Date.now() / 1000)\n    const secondsRemainingCalc = nextEventTime - currentSeconds\n    setSecondsRemaining(secondsRemainingCalc)\n\n    timer.current = setInterval(() => {\n      setSecondsRemaining((prevSecondsRemaining) => {\n        // Clear current interval at end of countdown and fetch current lottery to get updated state\n        if (prevSecondsRemaining <= 1) {\n          clearInterval(timer.current)\n          dispatch(setLotteryIsTransitioning({ isTransitioning: true }))\n          dispatch(fetchCurrentLottery({ currentLotteryId }))\n        }\n        return prevSecondsRemaining - 1\n      })\n    }, 1000)\n\n    return () => clearInterval(timer.current)\n  }, [setSecondsRemaining, nextEventTime, currentLotteryId, timer, dispatch])\n\n  return secondsRemaining\n}\n\nexport default useNextEventCountdown\n"]},"metadata":{},"sourceType":"module"}