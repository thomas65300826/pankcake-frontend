{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport maxBy from 'lodash/maxBy';\nimport merge from 'lodash/merge';\nimport range from 'lodash/range';\nimport { BIG_ZERO } from 'utils/bigNumber';\nimport { HistoryFilter, PredictionStatus } from 'state/types';\nimport { getPredictionsContract } from 'utils/contractHelpers';\nimport { getBetHistory, transformBetResponse, makeFutureRoundResponse, makeRoundData, getRoundsData, getPredictionData, getLedgerData, makeLedgerData, serializePredictionsRoundsResponse, getClaimStatuses } from './helpers';\nconst PAST_ROUND_COUNT = 5;\nconst FUTURE_ROUND_COUNT = 2; // The estimated time it takes to broadcast\n\nexport const BLOCK_PADDING = 3;\nconst initialState = {\n  status: PredictionStatus.INITIAL,\n  isLoading: false,\n  isHistoryPaneOpen: false,\n  isChartPaneOpen: false,\n  isFetchingHistory: false,\n  historyFilter: HistoryFilter.ALL,\n  currentEpoch: 0,\n  currentRoundStartBlockNumber: 0,\n  intervalBlocks: 100,\n  bufferBlocks: 20,\n  minBetAmount: '1000000000000000',\n  rewardRate: 97,\n  lastOraclePrice: BIG_ZERO.toJSON(),\n  rounds: {},\n  history: {},\n  ledgers: {},\n  claimableStatuses: {}\n}; // Thunks\n// V2 REFACTOR\n\nexport const initializePredictions = createAsyncThunk('predictions/intialize', async (account = null) => {\n  // Static values\n  const marketData = await getPredictionData();\n  const epochs = range(marketData.currentEpoch, marketData.currentEpoch - PAST_ROUND_COUNT); // Round data\n\n  const roundsResponse = await getRoundsData(epochs);\n  const initialRoundData = roundsResponse.reduce((accum, roundResponse) => {\n    const reduxNodeRound = serializePredictionsRoundsResponse(roundResponse);\n    return { ...accum,\n      [reduxNodeRound.epoch.toString()]: reduxNodeRound\n    };\n  }, {});\n  const initializedData = { ...marketData,\n    rounds: initialRoundData,\n    ledgers: {},\n    claimableStatuses: {}\n  };\n\n  if (!account) {\n    return initializedData;\n  } // Bet data\n\n\n  const ledgerResponses = await getLedgerData(account, epochs); // Claim statuses\n\n  const claimableStatuses = await getClaimStatuses(account, epochs);\n  return merge({}, initializedData, {\n    ledgers: makeLedgerData(account, ledgerResponses, epochs),\n    claimableStatuses\n  });\n});\nexport const fetchRound = createAsyncThunk('predictions/fetchRound', async epoch => {\n  const predictionContract = getPredictionsContract();\n  const response = await predictionContract.rounds(epoch);\n  return serializePredictionsRoundsResponse(response);\n});\nexport const fetchRounds = createAsyncThunk('predictions/fetchRounds', async epochs => {\n  const rounds = await getRoundsData(epochs);\n  return rounds.reduce((accum, round) => {\n    if (!round) {\n      return accum;\n    }\n\n    const reduxNodeRound = serializePredictionsRoundsResponse(round);\n    return { ...accum,\n      [reduxNodeRound.epoch.toString()]: reduxNodeRound\n    };\n  }, {});\n});\nexport const fetchMarketData = createAsyncThunk('predictions/fetchMarketData', async () => {\n  const marketData = await getPredictionData();\n  return marketData;\n});\nexport const fetchLedgerData = createAsyncThunk('predictions/fetchLedgerData', async ({\n  account,\n  epochs\n}) => {\n  const ledgers = await getLedgerData(account, epochs);\n  return makeLedgerData(account, ledgers, epochs);\n});\nexport const fetchClaimableStatuses = createAsyncThunk('predictions/fetchClaimableStatuses', async ({\n  account,\n  epochs\n}) => {\n  const ledgers = await getClaimStatuses(account, epochs);\n  return ledgers;\n}); // END V2 REFACTOR\n\nexport const fetchHistory = createAsyncThunk('predictions/fetchHistory', async ({\n  account,\n  claimed\n}) => {\n  const response = await getBetHistory({\n    user: account.toLowerCase(),\n    claimed\n  });\n  const bets = response.map(transformBetResponse);\n  return {\n    account,\n    bets\n  };\n});\nexport const predictionsSlice = createSlice({\n  name: 'predictions',\n  initialState,\n  reducers: {\n    setPredictionStatus: (state, action) => {\n      state.status = action.payload;\n    },\n    setHistoryPaneState: (state, action) => {\n      state.isHistoryPaneOpen = action.payload;\n      state.historyFilter = HistoryFilter.ALL;\n    },\n    setChartPaneState: (state, action) => {\n      state.isChartPaneOpen = action.payload;\n    },\n    setHistoryFilter: (state, action) => {\n      state.historyFilter = action.payload;\n    },\n    setCurrentEpoch: (state, action) => {\n      state.currentEpoch = action.payload;\n    },\n    setLastOraclePrice: (state, action) => {\n      state.lastOraclePrice = action.payload;\n    },\n    markBetHistoryAsCollected: (state, action) => {\n      const {\n        account,\n        betId\n      } = action.payload;\n\n      if (state.history[account]) {\n        const betIndex = state.history[account].findIndex(bet => bet.id === betId);\n\n        if (betIndex >= 0) {\n          state.history[account][betIndex].claimed = true;\n        }\n      }\n    }\n  },\n  extraReducers: builder => {\n    // Claimable statuses\n    builder.addCase(fetchClaimableStatuses.fulfilled, (state, action) => {\n      state.claimableStatuses = merge({}, state.claimableStatuses, action.payload);\n    }); // Ledger (bet) records\n\n    builder.addCase(fetchLedgerData.fulfilled, (state, action) => {\n      state.ledgers = merge({}, state.ledgers, action.payload);\n    }); // Get static market data\n\n    builder.addCase(fetchMarketData.fulfilled, (state, action) => {\n      const {\n        status,\n        currentEpoch,\n        intervalBlocks,\n        bufferBlocks,\n        minBetAmount,\n        rewardRate\n      } = action.payload; // If the round has change add a new future round\n\n      if (state.currentEpoch !== currentEpoch) {\n        const newestRound = maxBy(Object.values(state.rounds), 'epoch');\n        const futureRound = makeFutureRoundResponse(newestRound.epoch + 1, newestRound.startBlock + (state.intervalBlocks + BLOCK_PADDING));\n        state.rounds[futureRound.epoch] = futureRound;\n        state.currentRoundStartBlockNumber = state.currentRoundStartBlockNumber + state.intervalBlocks + BLOCK_PADDING;\n      }\n\n      state.status = status;\n      state.currentEpoch = currentEpoch;\n      state.intervalBlocks = intervalBlocks;\n      state.bufferBlocks = bufferBlocks;\n      state.minBetAmount = minBetAmount;\n      state.rewardRate = rewardRate;\n    }); // Initialize predictions\n\n    builder.addCase(initializePredictions.fulfilled, (state, action) => {\n      const {\n        status,\n        currentEpoch,\n        bufferBlocks,\n        intervalBlocks,\n        rounds,\n        claimableStatuses,\n        rewardRate,\n        ledgers\n      } = action.payload;\n      const currentRoundStartBlockNumber = action.payload.rounds[currentEpoch].startBlock;\n      const futureRounds = [];\n\n      for (let i = 1; i <= FUTURE_ROUND_COUNT; i++) {\n        futureRounds.push(makeFutureRoundResponse(currentEpoch + i, currentRoundStartBlockNumber + (intervalBlocks + BLOCK_PADDING) * i));\n      }\n\n      return { ...state,\n        status,\n        currentEpoch,\n        bufferBlocks,\n        intervalBlocks,\n        rewardRate,\n        currentRoundStartBlockNumber,\n        claimableStatuses,\n        ledgers,\n        rounds: merge({}, rounds, makeRoundData(futureRounds))\n      };\n    }); // Get single round\n\n    builder.addCase(fetchRound.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, {\n        [action.payload.epoch.toString()]: action.payload\n      });\n    }); // Get multiple rounds\n\n    builder.addCase(fetchRounds.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, action.payload);\n    }); // Show History\n\n    builder.addCase(fetchHistory.pending, state => {\n      state.isFetchingHistory = true;\n    });\n    builder.addCase(fetchHistory.rejected, state => {\n      state.isFetchingHistory = false;\n    });\n    builder.addCase(fetchHistory.fulfilled, (state, action) => {\n      const {\n        account,\n        bets\n      } = action.payload;\n      state.isFetchingHistory = false;\n      state.history[account] = bets;\n    });\n  }\n}); // Actions\n\nexport const {\n  setChartPaneState,\n  setCurrentEpoch,\n  setHistoryFilter,\n  setHistoryPaneState,\n  setPredictionStatus,\n  setLastOraclePrice,\n  markBetHistoryAsCollected\n} = predictionsSlice.actions;\nexport default predictionsSlice.reducer;","map":{"version":3,"sources":["/Users/thomas/Documents/pancake-frontend/src/state/predictions/index.ts"],"names":["createAsyncThunk","createSlice","maxBy","merge","range","BIG_ZERO","HistoryFilter","PredictionStatus","getPredictionsContract","getBetHistory","transformBetResponse","makeFutureRoundResponse","makeRoundData","getRoundsData","getPredictionData","getLedgerData","makeLedgerData","serializePredictionsRoundsResponse","getClaimStatuses","PAST_ROUND_COUNT","FUTURE_ROUND_COUNT","BLOCK_PADDING","initialState","status","INITIAL","isLoading","isHistoryPaneOpen","isChartPaneOpen","isFetchingHistory","historyFilter","ALL","currentEpoch","currentRoundStartBlockNumber","intervalBlocks","bufferBlocks","minBetAmount","rewardRate","lastOraclePrice","toJSON","rounds","history","ledgers","claimableStatuses","initializePredictions","account","marketData","epochs","roundsResponse","initialRoundData","reduce","accum","roundResponse","reduxNodeRound","epoch","toString","initializedData","ledgerResponses","fetchRound","predictionContract","response","fetchRounds","round","fetchMarketData","fetchLedgerData","fetchClaimableStatuses","fetchHistory","claimed","user","toLowerCase","bets","map","predictionsSlice","name","reducers","setPredictionStatus","state","action","payload","setHistoryPaneState","setChartPaneState","setHistoryFilter","setCurrentEpoch","setLastOraclePrice","markBetHistoryAsCollected","betId","betIndex","findIndex","bet","id","extraReducers","builder","addCase","fulfilled","newestRound","Object","values","futureRound","startBlock","futureRounds","i","push","pending","rejected","actions","reducer"],"mappings":"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","sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport maxBy from 'lodash/maxBy'\nimport merge from 'lodash/merge'\nimport range from 'lodash/range'\nimport { BIG_ZERO } from 'utils/bigNumber'\nimport { Bet, LedgerData, HistoryFilter, PredictionsState, PredictionStatus, ReduxNodeRound } from 'state/types'\nimport { getPredictionsContract } from 'utils/contractHelpers'\nimport {\n  getBetHistory,\n  transformBetResponse,\n  makeFutureRoundResponse,\n  makeRoundData,\n  getRoundsData,\n  getPredictionData,\n  MarketData,\n  getLedgerData,\n  makeLedgerData,\n  serializePredictionsRoundsResponse,\n  getClaimStatuses,\n} from './helpers'\n\nconst PAST_ROUND_COUNT = 5\nconst FUTURE_ROUND_COUNT = 2\n\n// The estimated time it takes to broadcast\nexport const BLOCK_PADDING = 3\n\nconst initialState: PredictionsState = {\n  status: PredictionStatus.INITIAL,\n  isLoading: false,\n  isHistoryPaneOpen: false,\n  isChartPaneOpen: false,\n  isFetchingHistory: false,\n  historyFilter: HistoryFilter.ALL,\n  currentEpoch: 0,\n  currentRoundStartBlockNumber: 0,\n  intervalBlocks: 100,\n  bufferBlocks: 20,\n  minBetAmount: '1000000000000000',\n  rewardRate: 97,\n  lastOraclePrice: BIG_ZERO.toJSON(),\n  rounds: {},\n  history: {},\n  ledgers: {},\n  claimableStatuses: {},\n}\n\n// Thunks\n// V2 REFACTOR\ntype PredictionInitialization = Pick<\n  PredictionsState,\n  | 'status'\n  | 'currentEpoch'\n  | 'intervalBlocks'\n  | 'bufferBlocks'\n  | 'minBetAmount'\n  | 'rewardRate'\n  | 'rounds'\n  | 'ledgers'\n  | 'claimableStatuses'\n>\nexport const initializePredictions = createAsyncThunk<PredictionInitialization, string>(\n  'predictions/intialize',\n  async (account = null) => {\n    // Static values\n    const marketData = await getPredictionData()\n    const epochs = range(marketData.currentEpoch, marketData.currentEpoch - PAST_ROUND_COUNT)\n\n    // Round data\n    const roundsResponse = await getRoundsData(epochs)\n    const initialRoundData: { [key: string]: ReduxNodeRound } = roundsResponse.reduce((accum, roundResponse) => {\n      const reduxNodeRound = serializePredictionsRoundsResponse(roundResponse)\n\n      return {\n        ...accum,\n        [reduxNodeRound.epoch.toString()]: reduxNodeRound,\n      }\n    }, {})\n\n    const initializedData = {\n      ...marketData,\n      rounds: initialRoundData,\n      ledgers: {},\n      claimableStatuses: {},\n    }\n\n    if (!account) {\n      return initializedData\n    }\n\n    // Bet data\n    const ledgerResponses = await getLedgerData(account, epochs)\n\n    // Claim statuses\n    const claimableStatuses = await getClaimStatuses(account, epochs)\n\n    return merge({}, initializedData, {\n      ledgers: makeLedgerData(account, ledgerResponses, epochs),\n      claimableStatuses,\n    })\n  },\n)\n\nexport const fetchRound = createAsyncThunk<ReduxNodeRound, number>('predictions/fetchRound', async (epoch) => {\n  const predictionContract = getPredictionsContract()\n  const response = await predictionContract.rounds(epoch)\n  return serializePredictionsRoundsResponse(response)\n})\n\nexport const fetchRounds = createAsyncThunk<{ [key: string]: ReduxNodeRound }, number[]>(\n  'predictions/fetchRounds',\n  async (epochs) => {\n    const rounds = await getRoundsData(epochs)\n    return rounds.reduce((accum, round) => {\n      if (!round) {\n        return accum\n      }\n\n      const reduxNodeRound = serializePredictionsRoundsResponse(round)\n\n      return {\n        ...accum,\n        [reduxNodeRound.epoch.toString()]: reduxNodeRound,\n      }\n    }, {})\n  },\n)\n\nexport const fetchMarketData = createAsyncThunk<MarketData>('predictions/fetchMarketData', async () => {\n  const marketData = await getPredictionData()\n  return marketData\n})\n\nexport const fetchLedgerData = createAsyncThunk<LedgerData, { account: string; epochs: number[] }>(\n  'predictions/fetchLedgerData',\n  async ({ account, epochs }) => {\n    const ledgers = await getLedgerData(account, epochs)\n    return makeLedgerData(account, ledgers, epochs)\n  },\n)\n\nexport const fetchClaimableStatuses = createAsyncThunk<\n  PredictionsState['claimableStatuses'],\n  { account: string; epochs: number[] }\n>('predictions/fetchClaimableStatuses', async ({ account, epochs }) => {\n  const ledgers = await getClaimStatuses(account, epochs)\n  return ledgers\n})\n// END V2 REFACTOR\n\nexport const fetchHistory = createAsyncThunk<{ account: string; bets: Bet[] }, { account: string; claimed?: boolean }>(\n  'predictions/fetchHistory',\n  async ({ account, claimed }) => {\n    const response = await getBetHistory({\n      user: account.toLowerCase(),\n      claimed,\n    })\n    const bets = response.map(transformBetResponse)\n\n    return { account, bets }\n  },\n)\n\nexport const predictionsSlice = createSlice({\n  name: 'predictions',\n  initialState,\n  reducers: {\n    setPredictionStatus: (state, action: PayloadAction<PredictionStatus>) => {\n      state.status = action.payload\n    },\n    setHistoryPaneState: (state, action: PayloadAction<boolean>) => {\n      state.isHistoryPaneOpen = action.payload\n      state.historyFilter = HistoryFilter.ALL\n    },\n    setChartPaneState: (state, action: PayloadAction<boolean>) => {\n      state.isChartPaneOpen = action.payload\n    },\n    setHistoryFilter: (state, action: PayloadAction<HistoryFilter>) => {\n      state.historyFilter = action.payload\n    },\n    setCurrentEpoch: (state, action: PayloadAction<number>) => {\n      state.currentEpoch = action.payload\n    },\n    setLastOraclePrice: (state, action: PayloadAction<string>) => {\n      state.lastOraclePrice = action.payload\n    },\n    markBetHistoryAsCollected: (state, action: PayloadAction<{ account: string; betId: string }>) => {\n      const { account, betId } = action.payload\n\n      if (state.history[account]) {\n        const betIndex = state.history[account].findIndex((bet) => bet.id === betId)\n\n        if (betIndex >= 0) {\n          state.history[account][betIndex].claimed = true\n        }\n      }\n    },\n  },\n  extraReducers: (builder) => {\n    // Claimable statuses\n    builder.addCase(fetchClaimableStatuses.fulfilled, (state, action) => {\n      state.claimableStatuses = merge({}, state.claimableStatuses, action.payload)\n    })\n\n    // Ledger (bet) records\n    builder.addCase(fetchLedgerData.fulfilled, (state, action) => {\n      state.ledgers = merge({}, state.ledgers, action.payload)\n    })\n\n    // Get static market data\n    builder.addCase(fetchMarketData.fulfilled, (state, action) => {\n      const { status, currentEpoch, intervalBlocks, bufferBlocks, minBetAmount, rewardRate } = action.payload\n\n      // If the round has change add a new future round\n      if (state.currentEpoch !== currentEpoch) {\n        const newestRound = maxBy(Object.values(state.rounds), 'epoch')\n        const futureRound = makeFutureRoundResponse(\n          newestRound.epoch + 1,\n          newestRound.startBlock + (state.intervalBlocks + BLOCK_PADDING),\n        )\n\n        state.rounds[futureRound.epoch] = futureRound\n        state.currentRoundStartBlockNumber = state.currentRoundStartBlockNumber + state.intervalBlocks + BLOCK_PADDING\n      }\n\n      state.status = status\n      state.currentEpoch = currentEpoch\n      state.intervalBlocks = intervalBlocks\n      state.bufferBlocks = bufferBlocks\n      state.minBetAmount = minBetAmount\n      state.rewardRate = rewardRate\n    })\n\n    // Initialize predictions\n    builder.addCase(initializePredictions.fulfilled, (state, action) => {\n      const { status, currentEpoch, bufferBlocks, intervalBlocks, rounds, claimableStatuses, rewardRate, ledgers } =\n        action.payload\n      const currentRoundStartBlockNumber = action.payload.rounds[currentEpoch].startBlock\n      const futureRounds: ReduxNodeRound[] = []\n\n      for (let i = 1; i <= FUTURE_ROUND_COUNT; i++) {\n        futureRounds.push(\n          makeFutureRoundResponse(\n            currentEpoch + i,\n            currentRoundStartBlockNumber + (intervalBlocks + BLOCK_PADDING) * i,\n          ),\n        )\n      }\n\n      return {\n        ...state,\n        status,\n        currentEpoch,\n        bufferBlocks,\n        intervalBlocks,\n        rewardRate,\n        currentRoundStartBlockNumber,\n        claimableStatuses,\n        ledgers,\n        rounds: merge({}, rounds, makeRoundData(futureRounds)),\n      }\n    })\n\n    // Get single round\n    builder.addCase(fetchRound.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, {\n        [action.payload.epoch.toString()]: action.payload,\n      })\n    })\n\n    // Get multiple rounds\n    builder.addCase(fetchRounds.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, action.payload)\n    })\n\n    // Show History\n    builder.addCase(fetchHistory.pending, (state) => {\n      state.isFetchingHistory = true\n    })\n    builder.addCase(fetchHistory.rejected, (state) => {\n      state.isFetchingHistory = false\n    })\n    builder.addCase(fetchHistory.fulfilled, (state, action) => {\n      const { account, bets } = action.payload\n\n      state.isFetchingHistory = false\n      state.history[account] = bets\n    })\n  },\n})\n\n// Actions\nexport const {\n  setChartPaneState,\n  setCurrentEpoch,\n  setHistoryFilter,\n  setHistoryPaneState,\n  setPredictionStatus,\n  setLastOraclePrice,\n  markBetHistoryAsCollected,\n} = predictionsSlice.actions\n\nexport default predictionsSlice.reducer\n"]},"metadata":{},"sourceType":"module"}