{"ast":null,"code":"import { ethers } from 'ethers';\nimport { getMulticallContract } from 'utils/contractHelpers';\n\nconst multicall = async (abi, calls) => {\n  try {\n    const multi = getMulticallContract();\n    const itf = new ethers.utils.Interface(abi);\n    const calldata = calls.map(call => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)]);\n    const {\n      returnData\n    } = await multi.aggregate(calldata);\n    const res = returnData.map((call, i) => itf.decodeFunctionResult(calls[i].name, call));\n    return res;\n  } catch (error) {\n    throw new Error(error);\n  }\n};\n/**\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\n *\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\n * 2. The return inclues a boolean whether the call was successful e.g. [wasSuccessfull, callResult]\n */\n\n\nexport const multicallv2 = async (abi, calls, options = {\n  requireSuccess: true\n}) => {\n  const {\n    requireSuccess\n  } = options;\n  const multi = getMulticallContract();\n  const itf = new ethers.utils.Interface(abi);\n  const calldata = calls.map(call => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)]);\n  const returnData = await multi.tryAggregate(requireSuccess, calldata);\n  const res = returnData.map((call, i) => {\n    const [result, data] = call;\n    return result ? itf.decodeFunctionResult(calls[i].name, data) : null;\n  });\n  return res;\n};\nexport default multicall;","map":{"version":3,"sources":["/Users/thomas/Documents/pancake-frontend/src/utils/multicall.ts"],"names":["ethers","getMulticallContract","multicall","abi","calls","multi","itf","utils","Interface","calldata","map","call","address","toLowerCase","encodeFunctionData","name","params","returnData","aggregate","res","i","decodeFunctionResult","error","Error","multicallv2","options","requireSuccess","tryAggregate","result","data"],"mappings":"AAAA,SAASA,MAAT,QAAuB,QAAvB;AACA,SAASC,oBAAT,QAAqC,uBAArC;;AAaA,MAAMC,SAAS,GAAG,OAAgBC,GAAhB,EAA4BC,KAA5B,KAA0D;AAC1E,MAAI;AACF,UAAMC,KAAK,GAAGJ,oBAAoB,EAAlC;AACA,UAAMK,GAAG,GAAG,IAAIN,MAAM,CAACO,KAAP,CAAaC,SAAjB,CAA2BL,GAA3B,CAAZ;AAEA,UAAMM,QAAQ,GAAGL,KAAK,CAACM,GAAN,CAAWC,IAAD,IAAU,CAACA,IAAI,CAACC,OAAL,CAAaC,WAAb,EAAD,EAA6BP,GAAG,CAACQ,kBAAJ,CAAuBH,IAAI,CAACI,IAA5B,EAAkCJ,IAAI,CAACK,MAAvC,CAA7B,CAApB,CAAjB;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAiB,MAAMZ,KAAK,CAACa,SAAN,CAAgBT,QAAhB,CAA7B;AAEA,UAAMU,GAAG,GAAGF,UAAU,CAACP,GAAX,CAAe,CAACC,IAAD,EAAOS,CAAP,KAAad,GAAG,CAACe,oBAAJ,CAAyBjB,KAAK,CAACgB,CAAD,CAAL,CAASL,IAAlC,EAAwCJ,IAAxC,CAA5B,CAAZ;AAEA,WAAOQ,GAAP;AACD,GAVD,CAUE,OAAOG,KAAP,EAAc;AACd,UAAM,IAAIC,KAAJ,CAAUD,KAAV,CAAN;AACD;AACF,CAdD;AAgBA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAME,WAAW,GAAG,OACzBrB,GADyB,EAEzBC,KAFyB,EAGzBqB,OAAyB,GAAG;AAAEC,EAAAA,cAAc,EAAE;AAAlB,CAHH,KAIS;AAClC,QAAM;AAAEA,IAAAA;AAAF,MAAqBD,OAA3B;AACA,QAAMpB,KAAK,GAAGJ,oBAAoB,EAAlC;AACA,QAAMK,GAAG,GAAG,IAAIN,MAAM,CAACO,KAAP,CAAaC,SAAjB,CAA2BL,GAA3B,CAAZ;AAEA,QAAMM,QAAQ,GAAGL,KAAK,CAACM,GAAN,CAAWC,IAAD,IAAU,CAACA,IAAI,CAACC,OAAL,CAAaC,WAAb,EAAD,EAA6BP,GAAG,CAACQ,kBAAJ,CAAuBH,IAAI,CAACI,IAA5B,EAAkCJ,IAAI,CAACK,MAAvC,CAA7B,CAApB,CAAjB;AACA,QAAMC,UAAU,GAAG,MAAMZ,KAAK,CAACsB,YAAN,CAAmBD,cAAnB,EAAmCjB,QAAnC,CAAzB;AACA,QAAMU,GAAG,GAAGF,UAAU,CAACP,GAAX,CAAe,CAACC,IAAD,EAAOS,CAAP,KAAa;AACtC,UAAM,CAACQ,MAAD,EAASC,IAAT,IAAiBlB,IAAvB;AACA,WAAOiB,MAAM,GAAGtB,GAAG,CAACe,oBAAJ,CAAyBjB,KAAK,CAACgB,CAAD,CAAL,CAASL,IAAlC,EAAwCc,IAAxC,CAAH,GAAmD,IAAhE;AACD,GAHW,CAAZ;AAKA,SAAOV,GAAP;AACD,CAjBM;AAmBP,eAAejB,SAAf","sourcesContent":["import { ethers } from 'ethers'\nimport { getMulticallContract } from 'utils/contractHelpers'\nimport { MultiCallResponse } from './types'\n\nexport interface Call {\n  address: string // Address of the contract\n  name: string // Function name on the contract (example: balanceOf)\n  params?: any[] // Function params\n}\n\ninterface MulticallOptions {\n  requireSuccess?: boolean\n}\n\nconst multicall = async <T = any>(abi: any[], calls: Call[]): Promise<T> => {\n  try {\n    const multi = getMulticallContract()\n    const itf = new ethers.utils.Interface(abi)\n\n    const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\n    const { returnData } = await multi.aggregate(calldata)\n\n    const res = returnData.map((call, i) => itf.decodeFunctionResult(calls[i].name, call))\n\n    return res\n  } catch (error) {\n    throw new Error(error)\n  }\n}\n\n/**\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\n *\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\n * 2. The return inclues a boolean whether the call was successful e.g. [wasSuccessfull, callResult]\n */\nexport const multicallv2 = async <T = any>(\n  abi: any[],\n  calls: Call[],\n  options: MulticallOptions = { requireSuccess: true },\n): Promise<MultiCallResponse<T>> => {\n  const { requireSuccess } = options\n  const multi = getMulticallContract()\n  const itf = new ethers.utils.Interface(abi)\n\n  const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\n  const returnData = await multi.tryAggregate(requireSuccess, calldata)\n  const res = returnData.map((call, i) => {\n    const [result, data] = call\n    return result ? itf.decodeFunctionResult(calls[i].name, data) : null\n  })\n\n  return res\n}\n\nexport default multicall\n"]},"metadata":{},"sourceType":"module"}