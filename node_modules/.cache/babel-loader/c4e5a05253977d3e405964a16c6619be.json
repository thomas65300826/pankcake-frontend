{"ast":null,"code":"var _jsxFileName = \"/Users/thomas/Documents/PycharmProjects/pancake-frontend/src/contexts/Localization/Provider.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { createContext, useCallback, useEffect, useState } from 'react';\nimport { EN, languages } from 'config/localization/languages';\nimport translations from 'config/localization/translations.json';\nimport { LS_KEY, fetchLocale, getLanguageCodeFromLS } from './helpers';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialState = {\n  isFetching: true,\n  currentLanguage: EN\n}; // Export the translations directly\n\nexport const languageMap = new Map();\nlanguageMap.set(EN.locale, translations);\nexport const LanguageContext = /*#__PURE__*/createContext(undefined);\nexport const LanguageProvider = ({\n  children\n}) => {\n  _s();\n\n  const [state, setState] = useState(() => {\n    const codeFromStorage = getLanguageCodeFromLS();\n    return { ...initialState,\n      currentLanguage: languages[codeFromStorage]\n    };\n  });\n  const {\n    currentLanguage\n  } = state;\n  useEffect(() => {\n    const fetchInitialLocales = async () => {\n      const codeFromStorage = getLanguageCodeFromLS();\n\n      if (codeFromStorage !== EN.locale) {\n        const enLocale = languageMap.get(EN.locale);\n        const currentLocale = await fetchLocale(codeFromStorage);\n        languageMap.set(codeFromStorage, { ...enLocale,\n          ...currentLocale\n        });\n      }\n\n      setState(prevState => ({ ...prevState,\n        isFetching: false\n      }));\n    };\n\n    fetchInitialLocales();\n  }, [setState]);\n\n  const setLanguage = async language => {\n    if (!languageMap.has(language.locale)) {\n      setState(prevState => ({ ...prevState,\n        isFetching: true\n      }));\n      const locale = await fetchLocale(language.locale);\n      const enLocale = languageMap.get(EN.locale); // Merge the EN locale to ensure that any locale fetched has all the keys\n\n      languageMap.set(language.locale, { ...enLocale,\n        ...locale\n      });\n      localStorage.setItem(LS_KEY, language.locale);\n      setState(prevState => ({ ...prevState,\n        isFetching: false,\n        currentLanguage: language\n      }));\n    } else {\n      localStorage.setItem(LS_KEY, language.locale);\n      setState(prevState => ({ ...prevState,\n        isFetching: false,\n        currentLanguage: language\n      }));\n    }\n  };\n\n  const translate = useCallback((key, data) => {\n    const translationSet = languageMap.has(currentLanguage.locale) ? languageMap.get(currentLanguage.locale) : languageMap.get(EN.locale);\n    const translatedText = translationSet[key] || key; // Check the existence of at least one combination of %%, separated by 1 or more non space characters\n\n    const includesVariable = translatedText.match(/%\\S+?%/gm);\n\n    if (includesVariable && data) {\n      let interpolatedText = translatedText;\n      Object.keys(data).forEach(dataKey => {\n        const templateKey = new RegExp(`%${dataKey}%`, 'g');\n        interpolatedText = interpolatedText.replace(templateKey, data[dataKey].toString());\n      });\n      return interpolatedText;\n    }\n\n    return translatedText;\n  }, [currentLanguage]);\n  return /*#__PURE__*/_jsxDEV(LanguageContext.Provider, {\n    value: { ...state,\n      setLanguage,\n      t: translate\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 103,\n    columnNumber: 10\n  }, this);\n};\n\n_s(LanguageProvider, \"UvfxiG++sY4Rfw2627vpN36DA/8=\");\n\n_c = LanguageProvider;\n\nvar _c;\n\n$RefreshReg$(_c, \"LanguageProvider\");","map":{"version":3,"sources":["/Users/thomas/Documents/PycharmProjects/pancake-frontend/src/contexts/Localization/Provider.tsx"],"names":["React","createContext","useCallback","useEffect","useState","EN","languages","translations","LS_KEY","fetchLocale","getLanguageCodeFromLS","initialState","isFetching","currentLanguage","languageMap","Map","set","locale","LanguageContext","undefined","LanguageProvider","children","state","setState","codeFromStorage","fetchInitialLocales","enLocale","get","currentLocale","prevState","setLanguage","language","has","localStorage","setItem","translate","key","data","translationSet","translatedText","includesVariable","match","interpolatedText","Object","keys","forEach","dataKey","templateKey","RegExp","replace","toString","t"],"mappings":"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","sourcesContent":["import React, { createContext, useCallback, useEffect, useState } from 'react'\nimport { Language } from '@pancakeswap/uikit'\nimport { EN, languages } from 'config/localization/languages'\nimport translations from 'config/localization/translations.json'\nimport { ContextApi, ContextData, ProviderState } from './types'\nimport { LS_KEY, fetchLocale, getLanguageCodeFromLS } from './helpers'\n\nconst initialState: ProviderState = {\n  isFetching: true,\n  currentLanguage: EN,\n}\n\n// Export the translations directly\nexport const languageMap = new Map<Language['locale'], Record<string, string>>()\nlanguageMap.set(EN.locale, translations)\n\nexport const LanguageContext = createContext<ContextApi>(undefined)\n\nexport const LanguageProvider: React.FC = ({ children }) => {\n  const [state, setState] = useState<ProviderState>(() => {\n    const codeFromStorage = getLanguageCodeFromLS()\n\n    return {\n      ...initialState,\n      currentLanguage: languages[codeFromStorage],\n    }\n  })\n  const { currentLanguage } = state\n\n  useEffect(() => {\n    const fetchInitialLocales = async () => {\n      const codeFromStorage = getLanguageCodeFromLS()\n\n      if (codeFromStorage !== EN.locale) {\n        const enLocale = languageMap.get(EN.locale)\n        const currentLocale = await fetchLocale(codeFromStorage)\n        languageMap.set(codeFromStorage, { ...enLocale, ...currentLocale })\n      }\n\n      setState((prevState) => ({\n        ...prevState,\n        isFetching: false,\n      }))\n    }\n\n    fetchInitialLocales()\n  }, [setState])\n\n  const setLanguage = async (language: Language) => {\n    if (!languageMap.has(language.locale)) {\n      setState((prevState) => ({\n        ...prevState,\n        isFetching: true,\n      }))\n\n      const locale = await fetchLocale(language.locale)\n      const enLocale = languageMap.get(EN.locale)\n\n      // Merge the EN locale to ensure that any locale fetched has all the keys\n      languageMap.set(language.locale, { ...enLocale, ...locale })\n      localStorage.setItem(LS_KEY, language.locale)\n\n      setState((prevState) => ({\n        ...prevState,\n        isFetching: false,\n        currentLanguage: language,\n      }))\n    } else {\n      localStorage.setItem(LS_KEY, language.locale)\n      setState((prevState) => ({\n        ...prevState,\n        isFetching: false,\n        currentLanguage: language,\n      }))\n    }\n  }\n\n  const translate = useCallback(\n    (key: string, data?: ContextData) => {\n      const translationSet = languageMap.has(currentLanguage.locale)\n        ? languageMap.get(currentLanguage.locale)\n        : languageMap.get(EN.locale)\n      const translatedText = translationSet[key] || key\n\n      // Check the existence of at least one combination of %%, separated by 1 or more non space characters\n      const includesVariable = translatedText.match(/%\\S+?%/gm)\n\n      if (includesVariable && data) {\n        let interpolatedText = translatedText\n        Object.keys(data).forEach((dataKey) => {\n          const templateKey = new RegExp(`%${dataKey}%`, 'g')\n          interpolatedText = interpolatedText.replace(templateKey, data[dataKey].toString())\n        })\n\n        return interpolatedText\n      }\n\n      return translatedText\n    },\n    [currentLanguage],\n  )\n\n  return <LanguageContext.Provider value={{ ...state, setLanguage, t: translate }}>{children}</LanguageContext.Provider>\n}\n"]},"metadata":{},"sourceType":"module"}